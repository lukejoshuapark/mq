package generate

import (
	"bufio"
	"fmt"
	"os"
	"slices"
	"strings"

	"github.com/lukejoshuapark/mq/cmd/text/parse"
)

func Generate(file parse.File, fileName string) error {
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	defer w.Flush()

	if err := generateHeader(file, w); err != nil {
		return err
	}

	return nil
}

func generateHeader(file parse.File, w *bufio.Writer) error {
	if _, err := w.WriteString("// This file was automatically generated by mq. DO NOT EDIT.\n"); err != nil {
		return err
	}

	if _, err := w.WriteString("package " + file.PackageName + "\n\nimport (\n"); err != nil {
		return err
	}

	file.Imports = append(file.Imports, "github.com/lukejoshuapark/mq")
	slices.Sort(file.Imports)

	for _, imp := range file.Imports {
		if _, err := w.WriteString("\t\"" + imp + "\"\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString(")\n\n"); err != nil {
		return err
	}

	return generateMockImplementations(file, w)
}

func generateMockImplementations(file parse.File, w *bufio.Writer) error {
	for _, intf := range file.Interfaces {
		if err := generateMockImplementation(intf, w); err != nil {
			return err
		}
	}

	return nil
}

func generateMockImplementation(intf parse.Interface, w *bufio.Writer) error {
	structName := "Mock" + intf.Name
	if _, err := w.WriteString("type " + structName + " struct {\n"); err != nil {
		return err
	}

	for _, method := range intf.Methods {
		lowerCaseName := getStringWithFirstLetterLowercase(method.Name)
		if _, err := w.WriteString("\t" + lowerCaseName + "Setups []Mock" + intf.Name + method.Name + "Setup\n"); err != nil {
			return err
		}

		if _, err := w.WriteString("\t" + lowerCaseName + "Calls []Mock" + intf.Name + method.Name + "Call\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("}\n\nvar _ " + intf.Name + " = &" + structName + "{}\n\n"); err != nil {
		return err
	}

	if _, err := w.WriteString("func New" + structName + "() *" + structName + " {\n\treturn &" + structName + "{}\n}\n\n"); err != nil {
		return err
	}

	return generateMethods(structName, intf, w)
}

func generateMethods(structName string, intf parse.Interface, w *bufio.Writer) error {
	for _, method := range intf.Methods {
		if err := generateMethod(structName, method, w); err != nil {
			return err
		}
	}

	return nil
}

func generateMethod(structName string, method parse.Method, w *bufio.Writer) error {
	typePrefix := structName + method.Name
	setupType := typePrefix + "Setup"
	callType := typePrefix + "Call"

	if _, err := w.WriteString("type " + setupType + " struct {\n"); err != nil {
		return err
	}

	for _, input := range method.Inputs {
		if _, err := w.WriteString("\t" + input.Name + " mq.Input[" + input.Type + "]\n"); err != nil {
			return err
		}
	}

	for i, output := range method.Outputs {
		outputName := getOutputName(output, i)
		if _, err := w.WriteString("\t" + outputName + " mq.Output[" + output.Type + "]\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("}\n\n"); err != nil {
		return err
	}

	if _, err := w.WriteString("type " + callType + " struct {\n"); err != nil {
		return err
	}

	for _, input := range method.Inputs {
		if _, err := w.WriteString("\t" + input.Name + " " + input.Type + "\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("}\n\n"); err != nil {
		return err
	}

	if err := generateSetupMethod(structName, method, w); err != nil {
		return err
	}

	if err := generateVerifyMethod(structName, method, w); err != nil {
		return err
	}

	if err := generateActualMethod(structName, method, w); err != nil {
		return err
	}

	return nil
}

func generateSetupMethod(structName string, method parse.Method, w *bufio.Writer) error {
	if _, err := w.WriteString("func (m *" + structName + ") Setup" + method.Name + "("); err != nil {
		return err
	}

	for i, input := range method.Inputs {
		if i != 0 {
			if _, err := w.WriteString(", "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString(input.Name + " mq.Input[" + input.Type + "]"); err != nil {
			return err
		}
	}

	for i, output := range method.Outputs {
		outputName := getOutputName(output, i)

		if i != 0 || len(method.Inputs) != 0 {
			if _, err := w.WriteString(", "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString(outputName + " mq.Output[" + output.Type + "]"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString(") {\n"); err != nil {
		return err
	}

	lowerCaseName := getStringWithFirstLetterLowercase(method.Name)
	if _, err := w.WriteString("\tm." + lowerCaseName + "Setups = append(m." + lowerCaseName + "Setups, " + structName + method.Name + "Setup{\n"); err != nil {
		return err
	}

	for _, input := range method.Inputs {
		if _, err := w.WriteString("\t\t" + input.Name + ": " + input.Name + ",\n"); err != nil {
			return err
		}
	}

	for i, output := range method.Outputs {
		outputName := getOutputName(output, i)

		if _, err := w.WriteString("\t\t" + outputName + ": " + outputName + ",\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("\t})\n}\n\n"); err != nil {
		return err
	}

	return nil
}

func generateVerifyMethod(structName string, method parse.Method, w *bufio.Writer) error {
	if _, err := w.WriteString("func (m *" + structName + ") Verify" + method.Name + "(count mq.Count"); err != nil {
		return err
	}

	for _, input := range method.Inputs {
		if _, err := w.WriteString(", "); err != nil {
			return err
		}

		if _, err := w.WriteString(input.Name + " mq.Input[" + input.Type + "]"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString(") {\n\tc := 0\n\n"); err != nil {
		return err
	}

	lowerCaseName := getStringWithFirstLetterLowercase(method.Name)
	if _, err := w.WriteString("\tfor _, call := range m." + lowerCaseName + "Calls {\n\t\tif "); err != nil {
		return err
	}

	for i, input := range method.Inputs {
		if i != 0 {
			if _, err := w.WriteString("&& "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString(input.Name + ".Compare(call." + input.Name + ") "); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("{\n\t\t\tc++\n\t\t}\n\t}\n\n"); err != nil {
		return err
	}

	if _, err := w.WriteString("\tif !count.ShouldPass(c) {\n"); err != nil {
		return err
	}

	// TODO: Improve panic.
	if _, err := w.WriteString("\t\tpanic(\"unexpected numbers of calls were made with those arguments\")\n\t}\n}\n\n"); err != nil {
		return err
	}

	return nil
}

func generateActualMethod(structName string, method parse.Method, w *bufio.Writer) error {
	if _, err := w.WriteString("func (m *" + structName + ") " + method.Name + "("); err != nil {
		return err
	}

	for i, input := range method.Inputs {
		if i != 0 {
			if _, err := w.WriteString(", "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString(input.Name + " " + input.Type); err != nil {
			return err
		}
	}

	if _, err := w.WriteString(") "); err != nil {
		return err
	}

	if len(method.Outputs) == 1 && method.Outputs[0].Name == "" {
		if _, err := w.WriteString(method.Outputs[0].Type + " {\n"); err != nil {
			return err
		}
	} else {
		if _, err := w.WriteString("("); err != nil {
			return err
		}

		for i, output := range method.Outputs {
			if i != 0 {
				if _, err := w.WriteString(", "); err != nil {
					return err
				}
			}

			if output.Name != "" {
				if _, err := w.WriteString(output.Name + " " + output.Type); err != nil {
					return err
				}
			} else {
				if _, err := w.WriteString(output.Type); err != nil {
					return err
				}
			}
		}

		if _, err := w.WriteString(") {\n"); err != nil {
			return err
		}
	}

	lowerCaseName := getStringWithFirstLetterLowercase(method.Name)
	if _, err := w.WriteString("\tfor _, setup := range m." + lowerCaseName + "Setups {\n\t\tif "); err != nil {
		return err
	}

	for i, input := range method.Inputs {
		if i != 0 {
			if _, err := w.WriteString("&& "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString("setup." + input.Name + ".Compare(" + input.Name + ") "); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("{\n\t\t\tm." + lowerCaseName + "Calls = append(m." + lowerCaseName + "Calls, " + structName + method.Name + "Call{\n"); err != nil {
		return err
	}

	for _, input := range method.Inputs {
		if _, err := w.WriteString("\t\t\t\t" + input.Name + ": " + input.Name + ",\n"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("\t\t\t})\n\n\t\t\treturn "); err != nil {
		return err
	}

	for i, output := range method.Outputs {
		outputName := getOutputName(output, i)

		if i != 0 {
			if _, err := w.WriteString(", "); err != nil {
				return err
			}
		}

		if _, err := w.WriteString("setup." + outputName + ".Value()"); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("\n\t\t}\n\t}\n\n"); err != nil {
		return err
	}

	// TODO: Improve panic.
	if _, err := w.WriteString("\tpanic(\"no setups were created with those arguments\")\n}\n\n"); err != nil {
		return err
	}

	return nil
}

func getOutputName(output parse.Field, i int) string {
	if output.Name != "" {
		return output.Name
	}

	return fmt.Sprintf("o%v", i)
}

func getStringWithFirstLetterLowercase(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}
